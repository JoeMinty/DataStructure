根据时间复杂度

**时间复杂度为O(n^2)的排序算法**

- 冒泡

是一种**交换排序**，稳定的排序

把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置，否则位置不变。

```java
  public void bubbleSort(int[] array) {
    for (int i = 0; i < array.length - 1; i++) {
      for (int j = 0; j < array.length - i - 1; j++) {
        if (array[j] > array[j + 1]) {
          int temp = array[j];
          array[j] = array[j + 1];
          array[j + 1] = temp;
        }
      }
    }
  }
```

冒泡排序的优化可以增加一个是否有序的标记位，避免多于的遍历

```java
  public void bubbleSort(int[] array) {
    for (int i = 0; i < array.length - 1; i++) {
      boolean isSort = true;
      for (int j = 0; j < array.length - i -1; j++) {
        if (array[j] > array[j + 1]) {
          int temp = array[j];
          array[j] = array[j + 1];
          array[j + 1] = temp;
          isSort = false;
        }
      }
      
      if (isSort) {
        break;
      }
    }
  }
```

继续优化，可以在每轮排序后，记录下来最后一次元素交换的位置，该位置即为无序数列的边界，再往后就是有序区了。

```java
  public void bubbleSort(int[] array) {
    int borderIndex = array.length - 1;
    for (int i = 0; i < array.length - 1; i++) {
      boolean isSort = true;
      int borderSortIndex = 0;  
      for (int j = 0; j < borderIndex; j++) {
        if (array[j] > array[j + 1]) {
          int temp = array[j];
          array[j] = array[j + 1];
          array[j + 1] = temp;
          isSort = false;
          borderSortIndex = j;
        }
      }
      
      borderIndex = borderSortIndex;
      if (isSort) {
        break;
      }
    }
  }
```

冒泡排序的升级排序**鸡尾酒排序**

优点是在特定条件下，减少排序的回合数，适用于**大部分元素已经有序**的情况

```java
  public static void cocktailSort(int[] array) {
        for (int i = 0; i < array.length / 2; i++) {
            boolean isSort = true;
            for (int j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                    isSort = false;
                }
            }

            if (isSort) {
                break;
            }

            isSort = true;

            for (int j = array.length - i - 1; j > i; j--) {
                if (array[j] < array[j - 1]) {
                    int temp = array[j];
                    array[j] = array[j - 1];
                    array[j - 1] = temp;
                    isSort = false;
                }
            }

            if (isSort) {
                break;
            }
        }
    }
```

- 选择

- 插入

- 希尔


**时间复杂度为O(nlogn)的排序算法**

- 快速排序

- 归并排序

- 堆排序

**时间复杂度为线性的排序算法**

- 计数排序

- 桶排序

- 基数排序
