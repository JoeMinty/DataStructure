## 概述
- 堆是一个完全二叉树（除了最后一层，其它层节点个数都是满的，最后一层的节点都靠左排列）

- 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值

## 二叉堆

- 最大堆的堆顶是整个堆中的最大元素
- 最小堆的堆顶是整个堆中的最小元素

堆排序算法的步骤

- 把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆，需要从大到小排序，则构建最小堆。

- 循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶

## 堆的操作
### 往堆中插入一个元素
调整的过程叫堆化**heapify**，堆化有两种（从上往下，从下往上）
```java
  public class Heap {
    /** 数组，从下标1开始存储数据 */
    private int[] a;
    
    /** 堆可以存储的最大数据个数 */
    private int n;
    
    /** 堆中已经存储的数据个数 */
    private int count;
    
    public Heap(int capacity) {
      a = new int[capacity + 1];
      n = capacity;
      count = 0;
    }
    
    public void insert(int data) {
      if (count >= n) return; // 满了
      
      ++count;
      a[count] = data;
      int i = count;
      // 自下往上堆化
      while (i / 2 > 0 && a[i] > a[i / 2]) {
        swap(a, i, i / 2);
        i = i / 2;
      }
    }
  }
```

### 删除堆顶元素
根据定义第二条，可以推断出堆顶元素存储的就是堆中数据的最大值或者最小值

```java
  public void removeMax() {
    if (count == 0) return -1; // 堆中没有数据
    
    a[1] = a[count];
    --count;
    heapify(a, count, 1);
  }
  
  private void heapify(int[] a, int n, int i) { // 自上往下堆化
    while (true) {
      int maxPos = i;
      if (i * 2 <= n && a[i] < a[i * 2]) 
        maxPos = i * 2;
      
      if (i * 2 + 1 <=n && a[maxPos] < a[i * 2 + 1])
        maxPos = i * 2 + 1;
       
      if (maxPos == i)
        break;
      
      swap(a, i, maxPos);
      i = maxPos;
    }
  }
```

### 基于堆实现排序
#### 建堆

#### 排序

