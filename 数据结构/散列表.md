## 散列函数
**hash(key)**

如何构造

- 散列函数计算得到的散列值是一个非负整数

- 如果key1 == key2，那么hash(key1) == hash(key2)

- 如果key != key2，那么hash(key1) != hash(key2)

## 散列冲突
### 开放寻址法
**线性探测**

步长为1，hash(key) + 0, hash(key) + 1, ……

**二次探测**

步长为二次方, hash(key) + 0, hash(key) + 1^2, hash(key) + 2^2

**双重散列**

总结

**当数据量比较小，装载因子小的时候，适合采用开放寻址法。**

**ThreadLocalMap**使用开放寻址法解决散列冲突的原因

### 链表法

**hashmap**

- 初始大小：

总结

**基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表**

## 如何设计散列函数
- 散列函数的设计不能太复杂

- 散列函数生成的值要尽可能随机并且均匀分布
